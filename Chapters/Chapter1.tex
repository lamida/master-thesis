% Chapter 1

\chapter{Introduction} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

Memory corruption errors have been a major security problem for almost 40
years~\cite{szekeresSoKEternalWar2013,vanderveenMemoryErrorsPresent2012}. The
errors often happen due to the use of unsafe languages, mainly C and C++. This
safety issue becomes a significant attack surface that affects the security of
many critical applications. The adversaries can hijack the program and taking
control to achieve their goals. Such an attack impacts a wide range of
applications, from distributed systems running in the cloud to IoT devices. 

Since the identification of these vulnerabilities, continuous arm races have
been ongoing between adversaries and defenders. As attackers find a
vulnerability, then different defense mechanisms are invented. After that,
attackers and researchers find another vulnerability that can circumvent or
disable the defense. Or sometimes, the solutions are not just practical to be
deployed. So far, we deploy some solutions such as non-executable stack (NX) or
Data Execution Prevention (DEP)  \( W \bigoplus R
\)~\cite{vanderveenMemoryErrorsPresent2012} Control Flow Integrity
(CFG)~\cite{abadiControlFlowIntegrityPrinciples2005},
ASLR~\cite{kilAddressSpaceLayout2006}, Stack
Canaries~\cite{baratlooTransparentRunTimeDefense2000} and more. Unfortunately
the war is not over.

In 2016, Abera et al. published a solution called C-Flat for detecting a
control-flow attack in runtime~\cite{aberaCFLATControlFlowAttestation2016}. The
detection is performed by mechanism called remote
attestation~\cite{haldarSemanticRemoteAttestationA2004}. The research focused on
attesting runtime control-flow attacks on IoT or other embedded devices. Since
then, many runtimes remote attestation schema are
introduced~\cite{dessoukyLOFATLowOverheadControl2017,
zeitouniATRIUMRuntimeAttestation2017, kohnhauserSCAPIScalableAttestation2017,
dessoukyLiteHAXLightweightHardwareassisted2018, aberaDIATDataIntegrity2019,
koutroumpouchosSecureEdgeComputing2019, sunOATAttestingOperation2020}. Like
C-Flat, most of those remote attestation schemes are targeting embedded systems.
One unique runtime remote attestation schema name ScaRR tries to cover remote
attestation beyond embedded application but also made it work for complex
system~\cite{toffaliniScaRRScalableRuntime2019}. 

This thesis study different model for runtime remote attestation. We zoom in the
ScaRR implementation due to the unique strength in making the attestation work
for a complex system.

\section{Motivation}

In this thesis, we want to answer these questions.
\begin{itemize}
    \item What are different remote attestation model that is available now and
    how do they differ?
    \item How to implement offline program analysis for the ScaRR novel model
    for remote attestation?
    \item How is the performance of the model?
\end{itemize}

\section{Related Works}

We discuss different runtime remote attestation models in this section.
Specifically, we discuss how different attestation schemes encode the offline
program representations.

C-Flat~\cite{aberaCFLATControlFlowAttestation2016} is the first remote
attestation scheme to detect runtime control flow attack for embedded systems.
C-Flat generates offline measurement by traversing all program's possible paths,
from the start node to the termination node. In each node, C-Flat hashes the
node ID and the hash of the previous node. In the first node, since there is no
previous hash, we pass 0. All of those steps create hash chains which we store
as offline measurement database.

C-Flat can attest exact flow path of a program from the hash chains information.
C-Flat does not need source code, because the offline measurement can be run on
the binary program. However, C-Flat has one limitation ---which is stated by the
authors--- on its inefficiencies for having to explore all possible paths from
program control flow graph~\cite{aberaCFLATControlFlowAttestation2016}.

Lo-Fat~\cite{dessoukyLOFATLowOverheadControl2017} improves C-Flat by using
hardware support for control flow attestation. The hardware intercepts the
instructions and process them in the components called branch filter and loop
monitor. With this hardware support, Lo-Fat incurs no performance overhead.
However, Lo-Fat control-flow representation still inherits C-Flat approach,
therefore it still induces high verification cost.

Atrium~\cite{zeitouniATRIUMRuntimeAttestation2017} is remote attestation scheme
that can provide resiliency against physical memory attacks where adversaries
can exploit the property of Time of Check Time of Use (TOCTOU) during
attestation. In the paper, the author describes memory bank attacks. In that
attack, the adversary can control instruction fetches to prevent detection.
During attestation time, the program fetches the instruction from the benign
memory area; when attestation does not run, the attack directs the fetch to the
malicious area.

Atrium calculates the offline program measurement slightly differently compared
with C-Flat and Lo-Fat. In Atrium, the verifier performs a one-time process to
generate CFG of the program. Then, Atrium computes hash measurement on the
instructions and addresses of basic blocks. C-Flat only hashes the node ID.
While this approach can mitigate the TOCTOU attack, the offline measurement
generation still grows exponentially as the complexity of the program increases.

LiteHax~\cite{dessoukyLiteHAXLightweightHardwareassisted2018} is hardware
assisted remote attestation scheme that allow verifier to detect these different
attacks:

\begin{itemize}
    \item Control-data attack such as code injection or code reuse attack like
    ROP.
    \item Non-control-data attack.
    \item Data-only attack such us DOP which do not affect control flow.
\end{itemize}

The offline measurement phase of LiteHax only generates program CFG without
calculating any hash over the whole control flows and data flow events. LiteHax
calculates hashes differently from previous schemes. However, in the online
prover-side verification time, provers still compute hashes and sending them as
reports to the verifier. Verifier does two processes on the reports. First, it
executes symbolic execution and then runs incremental forward data-flow
analysis. The two steps do not require any lookup to offline measurement
database.

Diat~\cite{aberaDIATDataIntegrity2019} is a remote attestation scheme that can
attest data integrity and control-flow of autonomous collaborative network
systems. The program attested must be decomposed into small interacting modules.
The scheme does the decomposition to improve the efficiency of the attestation.
LiteHax sets Data-flow monitorings between critical modules. Control path
attestation is being done against novel execution path representation using
multiset has (MSH) function~\cite{clarkeIncrementalMultisetHash2003}. The use of
MSH prevents the reconstruction of some execution order of the program.

OAT~\cite{sunOATAttestingOperation2020} is remote attestation scheme to attest
operation integrity of embedded device. OAT defines two types of measurements
for control flow attestation: a trace (for recording branches and jumps) and a
hash (for encoding returns). These two measurements are encoded as $H = Hash(H
\bigoplus RetAddr)$. OAT defines called that attestation blob.

During verification, the verifier reconstructs paths from the attestation blob.
The control flow violation is identified when the CFI check against an address is
failed or mismatched between hash and trace.

Although OAT does not encounter the combinatorial hash explosion in C-Flat,
there is a verification overhead since the verifier needs to reconstruct the
attestation blob. 
